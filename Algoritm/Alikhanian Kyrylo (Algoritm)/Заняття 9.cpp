#include <iostream>
#include <vector>
#include <climits>

using namespace std;

// Функція для реалізації алгоритму Дейкстри
void dijkstra(int graph[6][6], int start) {
    int dist[6];  // Масив для збереження найкоротших відстаней від початкової вершини
    bool visited[6] = { false };  // Масив для відстеження відвіданих вершин

    // Крок 1: Ініціалізація відстаней
    for (int i = 0; i < 6; i++) {
        dist[i] = INT_MAX;  // Встановлюємо початкові відстані як нескінченність
    }
    dist[start] = 0;  // Відстань від початкової вершини до себе = 0

    // Крок 2: Алгоритм Дейкстри
    for (int count = 0; count < 5; count++) {  // Повторюємо для кожної вершини
        // Знаходимо непосещену вершину з мінімальною відстанню
        int min = INT_MAX, u;
        for (int i = 0; i < 6; i++) {
            if (!visited[i] && dist[i] <= min) {  // Якщо вершина ще не відвідана
                min = dist[i];  // Оновлюємо мінімальну відстань
                u = i;  // Запам'ятовуємо вершину з мінімальною відстанню
            }
        }

        // Відмічаємо поточну вершину як відвідану
        visited[u] = true;

        // Оновлюємо відстані до сусідніх вершин
        for (int v = 0; v < 6; v++) {
            if (!visited[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v]) {
                dist[v] = dist[u] + graph[u][v];  // Оновлюємо відстань до сусідньої вершини
            }
        }
    }

    // Виведення найкоротших відстаней
    cout << "Найкоротші відстані від вершини " << start + 1 << ":\n";
    for (int i = 0; i < 6; i++) {
        cout << "Вершина " << i + 1 << ": " << dist[i] << endl;
    }
}

int main() {
    // Граф представленій у вигляді матриці суміжності
    int graph[6][6] = {
        {0, 1, 4, 0, 0, 0},  // Вершина 1 з'єднана з 2 (відстань 1) та 3 (відстань 4)
        {1, 0, 4, 2, 7, 0},  // Вершина 2 з'єднана з 1, 3, 4, 5
        {4, 4, 0, 3, 5, 0},  // Вершина 3 з'єднана з 1, 2, 4, 5
        {0, 2, 3, 0, 4, 6},  // Вершина 4 з'єднана з 2, 3, 5, 6
        {0, 7, 5, 4, 0, 7},  // Вершина 5 з'єднана з 2, 3, 4, 6
        {0, 0, 0, 6, 7, 0}   // Вершина 6 з'єднана з 4 та 5
    };

    int startNode = 0;  // Початкова вершина 1 (індекс 0)
    dijkstra(graph, startNode);  // Викликаємо функцію для обчислення найкоротших відстаней

    return 0;
}
